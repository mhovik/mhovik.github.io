<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Lecture 16 - Intro to Node.js</title>

    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <link rel="stylesheet" href="../../site/reveal/css/reveal.css">
    <link rel="stylesheet" href="../../site/reveal/css/theme/white.css" id="theme">

    <!-- Theme used for syntax highlighting of code -->
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">
    <link rel="stylesheet" href="../../site/reveal/lib/css/color-brewer.css">
    <link rel="stylesheet" href="../../site/reveal/css/154-override.css">

    <!-- Printing and PDF exports -->
    <script>
var link = document.createElement( 'link' );
link.rel = 'stylesheet';
link.type = 'text/css';
link.href = window.location.search.match( /print-pdf/gi ) ? '../../reveal/css/print/pdf.css' :
'../../reveal/css/print/paper.css';
document.getElementsByTagName( 'head' )[0].appendChild( link );
    </script>

    <!--[if lt IE 9]>
      <script src="lib/js/html5shiv.js"></script>
    <![endif]-->
  </head>

  <body>
    <div class="reveal">
      <!-- Any section element inside of this container is displayed as a slide -->
      <div class="slides">
        <!--
        <section>
          <iframe src="https://embed.polleverywhere.com/free_text_polls/T9cyvCSBPsB8ZQgiNMXaJ?controls=none&short_poll=true" width="800" height="600" frameBorder="0"></iframe>
        </section>
        -->

        <section>
          <h1>CSE 154</h1>
          <h3>Lecture 16: Intro to Node.js</h3>
          <p><a href="https://xkcd.com/869/">
            <img class="simpleimg" src="hidden/servers.png" alt="servers">
            </a>
          </p>
          <cite class="small-font">XKCD 869</cite>
        </section>
        <section>
          <h2>Agenda</h2>
          <p>Introduction to Module 4 and Node.js!</p>
        </section>

      <section>
        <h2>Review: Web Services</h2>
        <p>
          <strong>Web service</strong>: software functionality that can be invoked through the
          internet using common protocols</p>
        <p>It's like a remote function(s) you can call. Done by contacting a program on a web server</p>
        <ul>
          <li>Web services can be written in a variety of languages</li>
          <li>Many web services accept parameters and produce results</li>
          <li>Clients contact the server through the browser using XML over HTTP and/or AJAX Fetch code</li>
          <li>The service's output might be HTML but could be text, XML, JSON, or other content</li>
        </ul>
      </section>

      <section>
        <h3>Some Web Services We've Used as Clients</h3>
        <p>Merriam-Webster Dictionary API</p>
        <p>NASA APOD API</p>
        <p>Trivia API</p>
        <p>CSE154 web services:</p>
        <ul>
          <li>pokedex.php and game.php</li>
          <li>wpl.php</li>
          <li>mowgliscafe.php</li>
        </ul>
      </section>

      <section>
        <h3>So How Does a Web Service (like wpl.php) Respond to Requests?</h3>
          <img src="hidden/fullstackimage.png" alt="full stack analogy" class="no-border
          two-thirds-width centered-figure">
          <p class="font-16pt space-above">
            <a href="https://blog.codeanalogies.com/2018/04/07/front-end-v-back-end-explained-by-waiting-tables-at-a-restaurant/">Image source</a>
          </p>
      </section>
      <section>
        <h2>CSE 154 Modules: Where We're At</h2>
        <ol>
          <li>
            Webpage structure and appearance with HTML5 and CSS. <i class="fa fa-check
              good fragment" aria-hidden="true"></i>
          </li>
          <li>
            Client-side interactivity with JS DOM and events.<i class="fa fa-check
              good fragment" aria-hidden="true"></i>
          </li>
          <li>
            Using web services (API's) as a client with JS.<i class="fa fa-check
              good fragment" aria-hidden="true"></i>
          </li>
          <li class="bolded">
            Writing RESTful web services with Node.js and Express.
          </li>
          <li class="faded">
            Storing and retrieving information in a database with MySQL and server-side
            programs.
          </li>
        </ol>
      </section>
        <section>
          <h2>URLs and Web Servers</h2>
          <pre><code class="hljs" data-trim>https://server/path/file</code></pre>
          <p>Usually when you type a URL in your browser:</p>
          <ol>
            <li>Your computer looks up the server's IP address using
              <a href="https://en.wikipedia.org/wiki/Domain_Name_System">DNS</a>
            </li>
            <li>Your browser connects to that IP address and requests the given file</li>
            <li>
              The web server software (e.g. Apache) grabs that file from the server's local file
              system and then send back its contents to you
            </li>
          </ol>
          <p>
            Some URLs actually specify <em>programs</em> that the web server should run, and then
            send their output back to you as the result:
          </p>
          <p class="font-16pt">
            <a href="https://courses.cs.washington.edu/courses/cse154/webservices/pokedex/pokedex.php?pokedex=all">https://courses.cs.washington.edu/courses/cse154/webservices/pokedex/pokedex.php?pokedex=all</a>
          </p>
          <p>The above URL tells the server <code>courses.cs.washington.edu</code> to run the
          program <code>pokedex.php</code> and send back its output</p>
        </section>
        <section>
          <h3>Why Do We Need a Server to Handle Web Service Requests?</h3>
          <img src="hidden/server-analogy.png" class='no-border rightfigure' width="40%" alt="server analogy"/>
          <p>
            Servers are dedicated computers for processing data efficiently and delegating requests
            sent from many clients (often at once).
          </p>
          <p>
            These tasks are not possible (or appropriate) in the client's browser.
          </p>
        </section>

        <section>
          <h2>Languages for Server-Side Programming</h2>
          <p><img class="centered-figure" src="hidden/serversidelanguages2.png" alt="server side languages" style="width:50%"/></p>
          <p>Server-side programs are written using programming
          languages/frameworks such as
              <a href="http://php.net/docs.php" target="_blank">PHP</a>,
              <a href="https://www.tutorialspoint.com/jsp/" target="_blank">Java/JSP</a>,
              <a href="http://rubyonrails.org/" target="_blank">Ruby on Rails</a>,
              <a href="https://www.asp.net/" target="_blank">ASP.NET</a>,
              <a href="https://www.python.org/" target="_blank">Python</a>,
              <a href="https://www.perl.org/about.html" target="_blank">Perl</a>,
              and <a href="https://nodejs.org/en/" target="_blank">JS (Node.js)</a>
          </p>
          <p>Web servers contain software to run those programs and send back their output.</p>
        </section>
        <section>
          <h3>Our (New) Server-Side Language: JS (Node)</h3>
          <div>
            <img class="one-third-width" style="float: left;" src="hidden/nodejs.png" alt="NodeJS logo" />
            <ul class="two-thirds-width" style="float: left">
              <li>Open-source with an active developer community</li>
              <li>Flourishing package ecosystem</li>
              <li>Designed for efficient, asynchronous server-side programming</li>
              <li>You can explore other server-side languages after this course!</li>
            </ul>
          </div>
        </section>


        <section>
          <h2>What is Client-Side JS?</h2>
          <p>So far, we have used JS on the browser (client) to add interactivity to our web pages</p>
          <p>
            "Under the hood", your browser requests the JS (and other files) from a URL resource, loads the text file of the JS, and interprets it realtime in order to define how the web page behaves.</p>
          </p>
          <p>
            In Chrome, it does this using the V8 JavaScript engine, which is an open-source JS interpreter made by Google. Other browsers have different JS engines (e.g. Firefox uses SpiderMonkey).
          </p>
          <p>Besides the standard JS language features, you also have access to the DOM when running JS on the browser - this includes the <code>window</code> and <code>document</code></p>
        </section>

        <section>
         <h2>Client vs. Server-side JS</h2>
         <img class="centered-figure" src="hidden/js-client-server.png" alt="client vs. server-side js" />
        </section>

        <section>
          <h2>Node.js: Server-side JS</h2>
          <p>Node.js uses the same open-source V8 JavaScript engine as Chrome</p>
          <p>
            Node.js is a runtime environment for running JS programs using the same core language features, but outside of the browser.
          </p>
          <p>When using Node, <strong>you do not have access to the browser objects/functions (e.g. document, window, addEventListener)</strong>.</p>
          <p>Instead, you have access to functionality for managing HTTP requests, file i/o, and database interaction.</p>
          <p>This functionality is key to building REST APIs!</p>
        </section>

        <section>
          <h2>Getting started with Node.js</h2>
          <p>
            When you have Node installed (last week's section), you can run it immediately in the command line.
          </p>
          <ol>
            <li>Start an interactive REPL with <code>node</code> (no arguments). This REPL is much like the Chrome browser's JS console tab.</li>
            <li>Execute a JS program in the current directory with <code>node file.js</code></li>
          </ol>
        </section>

        <section>
          <h2>Starting a Node.js Project</h2>
          <p>There are a few steps to starting a Node.js application, but luckily most projects will follow the same structure.</p>
          <p>When using Node.js, you will mostly be using the command line (e.g. <code>php-ide-terminal</code> you should have installed in Atom).</p>
          <ol>
            <li>Start a new project directory (e.g. <code>node-practice</code>)</li>
            <li>Inside the directory, run <code>npm init</code> to initialize a <code>package.json</code> configuration file (you can keep pressing Enter to use defaults)</li>
            <li>Install any modules with <code>npm install &lt;package-name&gt;</code></li>
            <li>Write your Node.js file! (e.g. <code>app.js</code>)</li>
            <li>Include any front-end files in a <code>public</code> directory within the project.</li>
          </ol>
          <p>Along the way, a tool called <code>npm</code> will help install and manage packages that are useful in your Node app.</p>
        </section>

        <section>
          <h2>Starting a Node.js Project</h2>
          <p>Running <code>npm init</code> to create <code>package.json</code></p>
          <img class="centered-figure two-thirds-width" src="hidden/empty-project.png" alt="Starting an empty project" />
        </section>
        <section>
          <h2>Starting a Node.js Project</h2>
          <p>Running <code>npm init</code> to create <code>package.json</code></p>
          <img class="centered-figure two-thirds-width" src="hidden/after-npm-init.png" alt="Running npm init" />
        </section>
        <section>
          <h2>Starting <code>app.js</code></h2>
          <p>You can write and execute JS using Node in the command line</p>
          <img class="centered-figure two-thirds-width" src="hidden/hello-world-console.png" alt="Running node program on the command line" />
        </section>
        <section>
          <h2>Node.js Modules</h2>
          <p>
            When you run a <code>.js</code> file using Node.js, you have access to default functions in JS (e.g. <code>console.log</code>)</p>
          </p>
          <p>
            In order to get functionality like file i/o or handling network requests, you
            need to import that functionality from modules - this is similar to the <code>import</code> keyword you have used in Java or Python.
          </p>
          <p>
            In Node.js, you do this by using the <code>require()</code> function, passing the string name of the module you want to import.
          </p>

          <p>
            For example, the built-in module to provide HTTP request/response functionality in Node.js is called <code>http</code>. You can import it like this:
          </p>
<pre><code>const http = require("http");</code></pre>
<p class="code-caption">JS</p>
        </section>
        <section>
          <h3>Quick Note on <samp>const</samp> Keyword</h3>
          <p>Using <code>const</code> to declare a variable inside of JS just means that you can never change what that variable references. We've used this to represent "program constants" indicated by ALL_UPPERCASE naming conventions</p>
          <p>For example, the following code would not work:</p>
          <pre><code class="hljs">const specialNumber = 1;
specialNumber = 2; // TypeError: Assignment to constant variable.</code></pre>
        <p class="code-caption">JS</p>

          <p>
            When we store modules in Node programs, it is conventional to use <code>const</code> instead of <code>let</code> to avoid accidentally overwriting the module.</p>
          <p>Unlike the program constants we define with <code>const</code> (e.g. <code>BASE_URL</code>), we use camelCase naming instead of ALL_CAPS.</p>
        </section>
        <section>
          <h2>Our first Node server</h2>
          <p>The <code>http</code> core module provides functionality for handling HTTP requests.</p>
          <p>To get started with a simple server, we can write the following Node.js program:</p>
          <pre><code class="hljs font-12pt">"use strict";
const http = require("http");

let server = http.createServer((request, response) =&gt; {
  console.log("I got your request!");
  response.write("Hello from a Node Server!");
  response.end();
});

const PORT = process.env.PORT || 8000;
server.listen(PORT);</code></pre>
          <p class="code-caption">JS</p>
          <p>Try it! Save <code><a href="code/http-server-example.js" target="_blank">http-server-example.js</a></code> and then run <code>node http-server-example.js</code> in the command line when your current
          <p>What do you see in the browser? What do you see in the command line console?</p>
        </section>
        <section>
          <h2>APIs in Practice</h2>
          <p>As we add endpoints and different types of requests to our APIs, the <code>http</code> module can become very complicated. We will
            instead use the most popular web service module to implement our Node.js APIs, which is built using the same <code>http</code> module but with functionality that is much easier to use.</p>
          <p>But unlike <code>http</code>, Express is not a core module - it has been developed by a community of developers consistently updating it.</p>
          <p>But how can we use modules like Express in our own code?</p>
        </section>
        <section>
          <h3><a href="https://nodejs.dev/an-introduction-to-the-npm-package-manager" target="_blank">npm</a>: Node Package Manager</h3>
          <img src="hidden/npm-node.png" alt="npm is the Node Package Manager" />
          <p>Node comes with built-in "core modules" you can require in your project without extra installation (http, fs, path, etc.)</p>
          <p>But one of the appealing features of Node as a server-side technology is the extensive ecosystem of modules like Express to accomplish different tasks</p>
          <p>
            npm (Node Package Manager), gives us an easy way to download, manage, and update all of these packages.
          </p>
        </section>
        <section>
          <h2>Installing Packages</h2>
          <p>Node packages can be installed in two different ways, globally or locally.</p>
          <p>Global packages are installed by adding a <code>-g</code> flag in the npm install command and are accessible anywhere on your computer.</p>
          <pre><code>npm install -g &lt;package_name&gt;</code></pre>
          <p class="code-caption">command line</p>
          <p>This is useful if a package contains terminal commands that you want to be used at any time, such as the programs you installed last week (<code>nodemon</code> and <code>ndb</code>).</p>
        </section>
        <section>
          <h2>Local Packages</h2>
          <p>It's best practice to use local installation for project-specific packages.</p>
          <p>For example, we will use the Express module to build RESTful APIs in Node - each time we create a project, we will run the following within the project directory:
          </p>
          <pre><code>npm install express</code></pre>
          <p>npm will automatically add a dependency to the project's <code>package.json</code></p>
        </section>
        <section>
          <h2>Package Management</h2>
          <p>In addition to installing modules, npm will also automatically manage packages in your Node projects.</p>
          <p>Whenever you install a package, npm will add it to <code>package.json</code> and a <code>node_modules</code> folder</p>
          <p>These files should not be distributed with the rest of your project code (e.g. front-end files and <code>app.js</code> - <code>node_modules</code> can get very large</p>
          <p>Instead of sending this <code>node_modules</code> folder containing modules that already exist online, you send them an information file called <code>package.json</code> that NPM uses to keep track of all of these packages.</p>
          <p>
            When a user downloads your project and its <code>package.json</code> file, they just run <code>npm install</code> within the project directory, and npm will install all of those packages required to run the project.
          </p>
        </section>
        <section>
          <h2>npm's <samp>package.json</samp></h2>
          <p>
            The <code>package.json</code> file is created by running <code>npm init</code> which will prompt the user to answer a few questions about the project like the name and version.
          </p>
          <p>
            Any future <code>npm install &lt;package_name&gt;</code> commands that are run <em><strong>in the same project</strong></em> will be automatically added to this <code>package.json</code> file.
          </p>
          <p>
            A <code>package-lock.json</code> file will also be created, containing a more detailed version of all of the packages used in a project and their dependencies.</p>
        </section>

        <section>
          <h2>Express.js</h2>
          <p>Express.js is one of the most popular Node frameworks used to implement APIs</p>
          <p>Serves as an easy-to-use wrapper around Node's more complex core networking modules.</p>
          <p>Provides simple functionality through "middleware" to listen and respond to HTTP requests from clients at different endpoints.</p>
        </section>

        <section>
          <h2>Middleware</h2>
          <p>Middleware is a term you'll see when working with Express - it refers to any function that works "in the middle" of communication
            between the client and Node.js.</p>
            <!--
          <p>For example, we will use the <code>express.static</code> middleware function to specify the default directory of "static" client-facing files (HTML, CSS, client-side JS, images, etc.)</p>
        -->
          <p>Every middleware function has access to the request and response objects, and usually modifies the response to send.</p>
          <!--
          <p>You can add multiple middleware functions used in a single request-response cycle with <code>app.use</code>, but the last (usually <code>app.get</code>) must close the connection (e.g. with <code>res.send</code>) to prevent the
            connection to be left hanging.</p>
          -->

        </section>

        <section>
          <h2>Express as a Routing Mechanism for Node.js</h2>
          <img class="centered-figure full-width" src="hidden/request-flow-in-express.png" alt="Request flow with express and node.js" />
          <p class="citation right-align"><a href="https://github.com/rohit120582sharma/Documentation/wiki/Express-JS" target="_blank">Image source</a></p>
        </section>

        <section>
          <h2>Installing <code>express</code> module locally</h2>
          <p>To use Express, you must install it in the project directory with <code>npm install express</code>. This will automatically update <code>package.json</code> to include the dependency, and
          also create a <code>node_modules</code> directory (other modules you might install will also be added to <code>package.json</code> and <code>node_modules</code>).</p>
          <img class="centered-figure half-width" src="hidden/local-express-install.png" alt="Running node program on the command line" />
        </section>

        <section>
          <h3>Starting <code>app.js</code> as an Express REST API</h3>
          <p>You can write and execute JS using Node in the command line</p>
          <img class="centered-figure two-thirds-width" src="hidden/running-express-app.png" alt="Running express app with nodemon" />
        </section>

        <section>
          <h2>app.listen()</h2>
          <p>To start the localhost server to run your Express app, you need to specify a port to listen to.</p>
          <p>The express app object has a function <code>app.listen</code> which takes a port number and optional callback function</p>
          <p>At the bottom of your <code>app.js</code>, add the following code - (<code>process.env.PORT</code> is needed to use the default port when hosted on an actual server)</p>
          <pre><code>const PORT = process.env.PORT || 8000; // Allows us to change the port easily by setting an environment variable, so your app works with our grading software
app.listen(PORT);</code></pre>
</section>

        <section>
          <h2>Basic Routing in Express</h2>
          <p>Routes are used to define endpoints in your web service</p>
          <p>Express supports different HTTP requests - we will learn GET and POST</p>
          <p>Express will try to match routes in the order they are defined in your code</p>
        </section>

        <section class="font-16pt-slide">
          <h2>Adding Routes in Express.js</h2>
          <pre><code>app.get(path, (req, res) =&gt; {
  ...
});</code></pre>
          <p class="code-caption">JS</p>
          <ul>
            <li>
              <code>app.get</code> allows us to create a GET endpoint. It takes two
              arguments: The endpoint URL path, and a callback function for modifying/sending the response.
            </li>
            <li><code>req</code> is the request object, and holds items like the request parameters.</li>
            <li><code>res</code> is the response object, and has methods to send data to the client.</li>
            <li><code>res.set(...)</code> sets header data, like "content-type". Always set either "text/plain" or "application/json" with your response.</li>
            <li><code>res.send(<em>response</em>)</code> returns the response as HTML text to the client.</li>
            <li><code>res.json(<em>response</em>)</code> Does the same, but with a JSON object.</li>
          </ul>
          <p>
            When adding a route to the path, you will retrieve information from the request,
            and send back a response using res (e.g. setting the status code, content-type, etc.)
          </p>
          <p>If the visited endpoint has no matching route in your Express app, the response will be a 404 (resource not found)</p>
        </section>

        <section>
          <h2>Useful Request Properties/Methods</h2>
          <table class="code-table small-font">
            <tr>
              <th>Name</th>
              <th>Description</th>
            </tr>
            <tr>
              <td><a href="https://expressjs.com/en/4x/api.html#req.params">req.params</a></td>
              <td>Endpoint "path" parameters from the request</td>
            </tr>
            <tr>
              <td><a href="https://expressjs.com/en/4x/api.html#req.query">req.query</a></td>
              <td>query parameters from the request</td>
            </tr>
          </table>
        </section>

        <section>
          <h2>Useful Response Properties/Methods</h2>
          <table class="code-table small-font">
            <tr>
              <th>Name</th>
              <th>Description</th>
            </tr>
            <tr>
              <td><a href="https://expressjs.com/en/4x/api.html#res.write">res.write(data)</a></td>
              <td>Writes data in the response without ending the communication</td>
            </tr>
            <tr>
              <td><a href="https://expressjs.com/en/4x/api.html#res.end">res.end()</a></td>
              <td>Ends the process</td>
            </tr>
            <tr>
              <td><a href="https://expressjs.com/en/4x/api.html#res.send">res.send()</a></td>
              <td>Sends information back (default text with HTML content type)</td>
            </tr>
            <tr>
              <td><a href="https://expressjs.com/en/4x/api.html#res.json">res.json()</a></td>
              <td>Sends information back as JSON content type</td>
            </tr>
            <tr>
              <td><a href="https://expressjs.com/en/4x/api.html#res.set">res.set()</a></td>
              <td>Sets header information, such as "Content-type"</td>
            </tr>
            <tr>
              <td><a href="https://expressjs.com/en/4x/api.html#res.type">res.type()</a></td>
              <td>A convenience function to set content type (use "text" for "text/plain", use "json" for "application/json")</td>
            </tr>
            <tr>
              <td><a href="https://expressjs.com/en/4x/api.html#res.status">res.status()</a></td>
              <td>Sets the response status code</td>
            </tr>
            <tr>
              <td><a href="https://expressjs.com/en/4x/api.html#res.sendStatus">res.sendStatus()</a></td>
              <td>Sets the response status code with the default status text</td>
            </tr>
          </table>
        </section>
        <section>
          <h3>Setting the Content Type</h3>
          <p>By default, the content type of a response is HTML - we will only be sending plain text or JSON responses though in our web services</p>
          <p>To change the content type, you can use the <code>res.set</code> function, which is used to set response header information (e.g. content type).</p>
          <p>You can alternatively uses <code>res.type("text")</code> and <code>res.type("json")</code> which are equivalent to setting <code>text/plain</code> and <code>application/json</code> Content-Type headers, respectively.</p>
          <pre><code class="hljs">app.get('/hello', function (req, res) {
  // res.set("Content-Type", "text/plain");
  res.type("text"); // same as above
  res.send('Hello World!');
});</code></pre>
          <p class="code-caption">Setting plain text response</p>
          <pre><code class="hljs">app.get('/hello', function (req, res) {
  // res.set("Content-Type", "application/json");
  rese.type("json");
  res.send({ "msg" : "Hello world!" });
  // can also do res.json({ "msg" : "Hello world!"});
  // which also sets the content type to application/json
});</code></pre>
          <p class="code-caption">Setting JSON response content type</p>
        </section>

        <section>
          <h3>Adding our first "root" route</h3>
          <p>When you add a route in your Express app (here, we use '/' for the most basic "root" route), you can use <code>res.send</code> to send a response to the client (browser) and view using the port (here, 8000 on localhost)</p>
          <img class="centered-figure two-thirds-width" src="hidden/viewing-localhost.png" alt="Viewing app output on localhost" />
        </section>

        <section>
          <h3>Adding another route</h3>
          <p>You can add more routes in your file, and Express will use the first one matching the request path</p>
          <img class="centered-figure two-thirds-width" style="width: 80%" src="hidden/hello-route.png" alt="Viewing app output on localhost" />
        </section>

        <section>
          <h2>Request Parameters: Path Parameters</h2>
          <p>Act as wildcards in routes, letting a user pass in "variables" to an endpoint</p>
          <p>Define a route parameter with :param</p>
          <pre><code class="no-syntax-highlight">Route path: /states/:state/cities/:city
Request URL: http://localhost:8000/states/wa/cities/Seattle
req.params: { "state": "wa", "city": "Seattle" }</code></pre>

          <p>
            These are attached to the request object and can be accessed with req.params
          </p>
          <pre><code>app.get("/states/:state/cities/:city", function (req, res) {
  res.type("text");
  res.send("You sent a request for " + req.params.city + ", " + req.params.state);
});</code></pre>
          <p class="code-caption">JS</p>
        </section>

        <section>
          <h3>Adding route parameters: Example</h3>
          <img class="centered-figure two-thirds-width" style="width: 80%" src="hidden/route-parameter-example.png" alt="Viewing app output on localhost" />
        </section>

        <section>
          <h2>Request Parameters: Query Parameters</h2>
          <p>You can also use query parameters in Express using the <code>req.query</code> object, though they are more useful for optional parameters.</p>
          <pre><code>Route path: /cityInfo
Request URL: http://localhost:8000/cityInfo?state=wa&city=Seattle
req.query: { "state": "wa", "city": "Seattle" }</code></pre>
          <pre><code>app.get("/cityInfo", function (req, res) {
  let state = req.query.state; // wa
  let city = req.query.city;   // Seattle
  // do something with variables in the response
});</code></pre>
          <p class="code-caption">JS</p>
          <p>
            Unlike path parameters, these are not included in the path string (which are matched using Express routes) and we can't be certain that the accessed query key exists.
          </p>
          <p>
            If the route requires the parameter but is missing, you should send an error to the client in the response.
          </p>
        </section>
        <section>
          <h2>Setting Errors</h2>
          <p>The Response object has a <code>status</code> function which takes a status code as an argument.</p>
          <p>The 400 status code is what we'll use to send back an error indicating to the client that they made an invalid request.</p>
          <p>A helpful message should always be sent with the error.</p>
          <pre><code class="hljs">app.get("/cityInfo", function (req, res) {
  let state = req.query.state;
  let city = req.query.city;
  if (!(state && city)) {
    res.status(400).send("Error: Missing required city and state query parameters.");
  } else {
    res.send("You sent a request for " + city + ", " + state);
  }
});</code></pre>
<p class="code-caption">JS</p>
        </section>

        <section>
          <h2>Summary of Building an Express App</h2>
          <ol>
            <li>Create a file (e.g. <code>app.js</code>)</li>
            <li>Add required modules at the top (at minimum, <code>require(“express”)</code>)</li>
            <li>Create an app instance: <code>const app = express();</code></li>
            <li>At the end of the file, listen to a port (e.g. 8000)</li>
            <li>Add routes! Remember that “/” stands for the basic root route, which can be visited in your browser at localhost:8000/ when your app is running.</li>
          </ol>
        </section>


        <!-- end of slides (last section tag) -->
      </div>
    </div>
   <script src="../../site/reveal/lib/js/head.min.js"></script>
      <script src="../../site/reveal/js/reveal.js"></script>

      <script>

        Reveal.initialize({
          controls: true,
          progress: true,
          history: true,
          center: true,

          transition: 'slide', // none/fade/slide/convex/concave/zoom

          // More info https://github.com/hakimel/reveal.js#dependencies
          dependencies: [
            { src: '../../site/reveal/lib/js/classList.js', condition: function() { return !document.body.classList; } },
            { src: '../../site/reveal/plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
            { src: '../../site/reveal/plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
            { src: '../../site/reveal/plugin/highlight/highlight.pack.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
            { src: '../../site/reveal/plugin/zoom-js/zoom.js', async: true },
            { src: '../../site/reveal/plugin/notes/notes.js', async: true },
            { src: '../../site/reveal/plugin/search/search.js', async: true },
            { src: '../../site/reveal/plugin/print-pdf/printpdfbtn.js', async: true }
          ]
        });

      </script>

    </body>
  </html>
