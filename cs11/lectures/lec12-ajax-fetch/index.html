<!doctype html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<title>Lecture 12: Promises and fetch</title>

    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <link rel="stylesheet" href="../../site/reveal/css/reveal.css">
    <link rel="stylesheet" href="../../site/reveal/css/theme/white.css" id="theme">

    <!-- Theme used for syntax highlighting of code -->
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">
    <link rel="stylesheet" href="../../site/reveal/lib/css/color-brewer.css">
    <link rel="stylesheet" href="../../site/reveal/css/154-override.css">

    <!-- Printing and PDF exports -->
    <script>
      var link = document.createElement( 'link' );
      link.rel = 'stylesheet';
      link.type = 'text/css';
      link.href = window.location.search.match( /print-pdf/gi ) ? '../../site/reveal/css/print/pdf.css' :
      '../../site/reveal/css/print/paper.css';
      document.getElementsByTagName( 'head' )[0].appendChild( link );
    </script>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>

    <!--[if lt IE 9]>
    <script src="lib/js/html5shiv.js"></script>
    <![endif]-->
  </head>
	<body>
		<div class="reveal">
			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">
        <section>
          <h2>Lecture 12</h2>
          <h3>Promises and Fetch</h3>
        </section>
        <section>
          <h2>Administrivia</h2>
          <p>Exam 1 Monday - Review Session in LOW 105 Saturday 1:30-3:30</p>
        </section>
        <section>
          <h2>Warm-up</h2>
          <a href="code/callback-cookies.html">Callback Cookies</a>
        </section>
        <section>
          <h2>Agenda</h2>
          <p>AJAX and Fetching Data Asynchronously</p>
          <p>What is a Promise?</p>
          <p>APIs</p>
        </section>
        <section>
          <h2>The Challenge with Asynchronous Programs</h2>
          <p>Asynchronous programs are great to start tasks immediately without blocking other functions.
            But when there are dependencies for asynchronous functions, we run into "callback hell".
          </p>
          <pre><code class="font-12pt">function order() {
  setTimeout(function() {
    makeRequest("Requesting menu...");
    setTimeout(function() {
      makeRequest("Ordering pizza...");
      setTimeout(function() {
        makeRequest("Checking pizza...");
        setTimeout(function() {
          makeRequest("Eating pizza...");
          setTimeout(function() {
            makeRequest("Paying for pizza...");
            setTimeout(function() {
              let response = makeRequest("Done! Heading home.");
              console.log(response);
            });
          });
        });
      });
    });
  });
}</code></pre>
<p class="code-caption">JS</p>
</section>
    <section>
      <h2>Server Requests</>
      <pre><code class="font-12pt">makeRequestToServer(firstUrl, dataToServer, function(response1) {
    // function to call when server is done responding
    let jsonData = JSON.parse(response1);
    processResponse1(jsonData, function(processedData1) {
        getUserInput(processedData1, function(userReponse) {
            makeRequestToServer(secondUrl, userReponse, function(response2) {
                processResponse2(response2, function(processedData2) {
                    // Do something with processedData2.
                });
            });
        });
    });
}</code></pre>
         <p class="code-caption">JS (psuedocode)</p>

       <p>Code is very confusing and hard to follow the logical flow of execution and data</p>
       <p>What if we could attach callback functions for each step like a pipeline to be easier to follow?</p>
     </section>


        <section>
          <h2>Fetching Data Asynchronously</h2>
      <ul>
        <li>What kind of data can we get from the internet?</li>
        <li>How do we request data from the internet?</li>
        <li>What happens when something goes wrong on the internet?</li>
        <li>Can you trust everything you find on the internet?</li>
      </ul>
    </section>

   <section>
     <h2>Asynchronous Programs</h2>
     <img class="centered-figure half-width" src="hidden/images/async-diagram.png" alt="asynchronous request diagram">
     <p>We've seen asynchronous requests with <code>setTimeout</code> and <code>setInterval</code> (refer to <code>bakeCookies</code> warmup)</p>
     <p>Timer callback functions are called after a fixed <code>delayMs</code> and don't have uncertain behavior</p>
     <p>AJAX callback functions are <em>not</em> guaranteed to execute after a fixed timespan, and their responses are uncertain (resolved or rejected)</p>
   </section>
   <section>
     <h2>AJAX the "old way" (XML over HTTP)</h2>

     <p>
       Using Javascript to pull in more content from the server without
       navigating the page to a new url
     </p>
     <p>
       Although we are showing you this, it is for context only, we will
       not be using the "XML over HTTP" method of AJAX calls.
     </p>
        <pre><code class="hljs" data-trim>let xhr = new XMLHttpRequest();
xhr.open(method, url, [async/sync]);
xhr.onload = function() { /* handle success */ };
xhr.onerror = function() { /* handle failure */ };
xhr.send(); </code></pre>
          <p class="code-caption" data-trim>JS (template)</p>
          <pre><code class="hljs">let xhr = new XMLHttpRequest();
xhr.open("GET", "https://cse154.appspot.com/cafeexample/getCategories");
xhr.onload = function() { alert(this.responseText); };
xhr.onerror = function() { alert("ERROR!"); };
xhr.send();</code></pre>
            <p class="code-caption">JS (example)</p>
        </section>
        <section>
          <h2>AJAX with the Fetch API</h2>
          <pre><code class="hljs" data-trim>(function(){
        ...
function doWebRequest() {
  const url = ..... // put url string here
  fetch(url); // returns a Promise!
}</pre></code>
          <p class="code-caption">JS (template)</p>
        </section>

        <section>
          <h2>Now: AJAX with the Fetch API</h2>
          <p>
            The Fetch API was created in 2014 and incorporated into the global <code>window</code>.
          </p>
          <p>
            <code>fetch</code> takes a URL string as a parameter to request
            data (e.g. menu category JSON) that we can work with in our JS file.
          </p>
          <pre><code class="hljs" data-trim>function populateMenu() {
  const URL = "https://cse154.appspot.com/cafeexample/";
  fetch(URL + "/getCategories") // returns a Promise!
    .then(...)
    .then(...)
    .catch(...)
 }</pre></code>
          <p class="code-caption">JS (example)</p>
        <p>
            We need to do something with the data that
            comes back from the server.
          </p>
          <p>
            But we don't know how long that will take or if it even will
            come back correctly!
          </p>
          <p>
            The <code>fetch</code> call returns a <code>Promise</code> object which will help
            us with this uncertainty.
          </p>

        </section>
        <section>
          <h1>Promises</h1>
          <p>
            Turn asynchronous code into re-usable synchronous "objects" that can be (eventually) resolved or rejected
            while letting the program continue working.
          </p>
          <p>Much easier to manage asynchronous and synchronous tasks without "callback hell"</p>
        </section>

        <section>
          <h2>States of a Promise</h2>
          <div class="side-by-side">
          <img src="../img/promise-states.jpg" alt="Three states of a Promise: pending, resolved, rejected" />
        <div>
            <p>
              Promises have three states:
            </p>
            <ul>
                <li>Pending: When initially constructed</li>
                <li>Fulfilled: When resolved</li>
                <li>Rejected: When rejected</li>
            </ul>
          </div>
          </div>
            <p>Can only go from Pending to Fullfilled or Rejected (no takebacks)</p>

            <p>
                Example: â€œI promise to return to your table"
            </p>
            <ul>
                <li>Pending: Waiter hasn't yet returned</li>
                <li>Fulfilled: Waiter has returned your order</li>
                <li>Rejected: Kitchen ran out of ingredients</li>
            </ul>
        </section>

        <section>
            <h3>Constructing a JavaScript Promise</h3>

            <pre><code class="hljs" data-trim>let promise = new Promise(executorFn); // syntax

let customPromise = new Promise(function(resolve, reject) {
  // do something asynchronous (like make an ajax call, set a timeout)
  if (success) {
    resolve(result); // Set to fulfilled
  } else {
    reject(reason);  // Set to rejected
  }
});</code></pre>
            <p class="code-caption" data-trim>JS (template)</p>
          </section>
 <section>
   <h2>Examples of 2 Executor Functions</h2>
   <pre><code class="font-12pt">// Always fulfills the promise, calling resolve in 1 second.
function alwaysYesIn1Second(resolve, reject) {
  // this function is always certain, don't need to handle reject
  setTimeout(() => resolve("Yes"), 1000);
}

function maybeNoIn1Second(resolve, reject) {
 setTimeout(() => {
   if (Math.random() < 0.5) {
     resolve("Success! You get a duck.");
   } else {
     reject(Error("You lost, no duck."));
   }
  }, 1000);
}

// a Promise constructor
function maybePromise() {
  return new Promise(maybeNoIn1Second);
}</code></pre>
<p class="code-caption">JS</p>
              </section>
            <section class="font-14pt-slide">
              <h3>The Executor: Resolve and Reject</h3>
              <p>When a Promise is constructed, its executor function is ran immediately (usually performing some asynchronous code)</p>
              <div class="side-by-side" style="align-items: center;">
              <img src="../img/promise-states.jpg" style="width: 45%;" alt="Three states of a Promise: pending, resolved, rejected" />
              <div style="width: 53%">
              <p>When the executor calls <code>resolve</code>:</p>
                <ol>
                  <li>The Promise's value is updated to the <code>resolve</code> argument (e.g. "Promise fulfilled! ...")</li>
                  <li>The Promise's state is updated to "resolved"</li>
                </ol>

              <p>When the executor calls <code>reject</code>:</p>
              <ol>
                <li>The Promise's value is updated to the <code>resolve</code> argument (often an Error called a "reason")</li>
                <li>The Promise's state is updated to "rejected"</li>
              </ol>
            </div>
          </div>
<pre><code class="font-12pt">function someExecutor(resolve, reject) {
 setTimeout(() =&gt; { // some asynchronous (delayed and uncertain) code
   if (Math.random() &lt; 0.5) {
     resolve("Promise fulfilled! I now hold this String.");
   } else {
     reject(Error("Promise not fulfilled :("));
   }
}, 1000);

let p = new Promise(someExecutor); // we now have "packaged" uncertain behavior!
</code></pre>
<p class="code-caption">JS</p>
        </section>

        <section>
          <h3>Simulating a "Fake Server" Request with a Promise</h3>
              <p>
                When we are using a constructed Promise, we can get its resolved value using <code>.then</code>.
              </p>
<pre><code class="font-12pt">function fakeServer(resolve, reject) {
 setTimeout(() =&gt; {
   if (Math.random() &lt; 0.5) {
     resolve("Success! Here's a fancy String.");
   } else {
     reject(new Error("I couldn't fulfill your request :("));
   }
  }, 1000);
}

let p = new Promise(fakeServer);

p.then(function(result) {
  console.log("Promise resolved: " + result);
}).catch(function(result) {
  console.log("Promise rejected: " + err);
});</code></pre>
<p class="code-caption">JS</p>
<p>Try copy/pasting the above in the Chrome console! What happens which you change the timeout delay?</p>
            </section>

              <section>
              <h2>Using Promises with <code>fetch</code></h2>
              <p>
                We won't be constructing Promises, but will be using them when we <code>fetch</code> information from a
                server, which is an uncertain task
              </p>
              <p>
                The returned <code>Promise</code> contains a value that is a <code>Response</code> from the requested resource,
                which we can get <code>then.</code> after the fetch call.
              </p>
              <pre><code class="hljs">fetch(url).then((resp) =&gt; {
    // resp is a Response object!
});</code></pre>
              <p class="code-caption">JS</p>
              <p>
                What's in a <code>Response</code>?
              </p>
            </section>
            <section class="font-16pt-slide">
              <h2>The <code>Response</code> object</h2>
            <table class="code-table med-font-table">
              <tr>
                <th>Property</th>
                <th>Description</th>
              </tr>
              <tr>
                <td>response.status</td>
                <td>Status code (e.g. 200, 400, etc.)</td>
              </tr>
              <tr>
                <td>response.ok</td>
                <td>Whether the response has a success (2XX) status code, short for:<br>
                  <samp>response.status &gt; 200 &amp;&amp; response.status &lt;= 300</samp>)</td>
              </tr>
              <tr>
                <td>response.statusText</td>
                <td>Status text returned in the response (e.g. "200 OK", "400 Bad Request", "503 Service Unavailable")</td>
              </tr>
              <tr>
                <td>response.json(), response.text()</td>
                <td>Methods to extract the response body depending on the data format</p>
              </tr>
            </table>
              <p>We will use the Response returned (in a Promise) from <code>fetch</code> to:</p>
              <ol>
                <li>Check <code>response.ok</code></li>
                <li>If not, throw an Error which will jump immediately to a <code>catch</code> statement. It's good
                to construct the Error with details about the <code>response.statusText</code></li>
                <li>Otherwise, extract the data we want with <code>response.text()</code> or <code>response.json()</code></li>
              </ol>
            </section>
            <section>
                <h3>AJAX <code>fetch</code> Code Skeleton: V1</h3>

                <pre><code class="hljs font-12pt" data-trim>function fetchTheData() {
  let url = URL + possibleParameters;
  fetch(url)
    .then(function(response) {
      if (!response.ok) { // response.status < 200 || response.status >= 300
        throw Error("Error in request: " + response.statusText);
      }
      return response; // only reach here if no Error thrown
    })
    .then(function(response) {
       return response.json();   // for JSON responses
       // return response.text(); // for text responses
    })
    .then(function(data) {
       // success: do something with the data (JSON or text)
    })
    .catch(function(err) {
       // error: handle request error (e.g. display message
       // on the page)
    });
}</code></pre>
          <p class="code-caption">JS (template)</p>
        </section>

        <section class="font-14pt-slide" id="ajax-fetch-skeleton">
        <h3>
            AJAX <code>fetch</code> Code Skeleton (better version)
        </h3>
        <p>
          The following is much easier to read, and factors out
          larger callback functions into named functions. Remember that the return of each callback
          function passed to a <code>then</code> is exactly the argument passed into the callback of the next <code>then</code>.
        </p>
        <p>For short callbacks, we also see the motivation with arrow function syntax!</p>
        <pre class="h400px font-12pt"><code class="hljs" data-trim>function fetchTheData() {
  fetch(url + possibleParameters)
    .then(checkStatus)
    .then(response => response.json())    // if json
    // .then(response => response.text()) // if text
    .then(processResponse)
    .catch(handleError);
  }
}

function processResponse(data) { // success: do something with the response data }

function handleError(err) { // e.g. display helpful error message on the page }

// You should use this always after fetch and before processing the data
function checkStatus(response) {
  if (!response.ok) {
    throw Error("Error in request: " + response.statusText);
  }
  return resp; // a Response object
}</code></pre>
          <p class="code-caption">JS (template)</p>
        </section>
        <section>
          <h2>Looking Ahead</h2>
          <p>
            Make sure to focus on studying for the midterm, but on Tuesday and Wednesday we'll
            practice using fetch with different APIs and response types (JSON and text) and talk more about
            the fetch pipeline shown in the previous slides.
          </p>
        </section>

<!--

   <section>
     <h2>Fetching data from a web service</h2>
     <p>To make a request to a web service (API), we need to know:</p>
     <ol class="font-18pt">
       <li>Who to ask (the url)
         <ul class="fragment">
           <li>Example:
             <a
         href="https://courses.cs.washington.edu/courses/cse154/webservices/recipe/recipe.php">https://courses.cs.washington.edu/courses/cse154/webservices/recipe/recipe.php</a></li>
           <li>Example: <a href="http://numbersapi.com">http://numbersapi.com</a></li>
         </ul>
       </li>
       <li>Do we have permission to ask (any API keys/tokens)
         <ul class="fragment">
           <li>Not in <samp>numbersapi.com</samp>, but NASA/TMDB require them; add as additional query parameter</li>
         </ul>
       <li>What to ask (any query parameters)
         <ul class="fragment">
           <li>Differ per API, some have specific order of parameter values,
             separated by /, others have explicit key/value pairs started with ? and
             combined with &amp;
           </li>
           <li>Example: A Recipes API might have
             <br>
             <samp>recipe.php?recipe=cupcake&amp;vegan=true</samp>
           </li>
           <li>Example: Numbers API: <a
         href="http://numbersapi.com/154/math" target="_blank">http://numbersapi.com/154/math</a>)
           </li>
         </ul>
       </li>
       <li>What format we get answers in (the response data format, preferrably txt or JSON)</li>
     </ol>
   </section>

     <section id="apod">
       <h3>Example: NASA APOD (Astronomy Photo of the Day) API</h3>
       <ol>
         <li>What kind of format is the response data? <strong
class="fragment">JSON</strong></li>
         <li>Do you need an API key? <strong class="fragment">Yes*</strong> <span
                                             class="fragment">*(but you can
                                             make 50 calls per day with "DEMO_KEY" as your api key parameter!</span>
         <li>What is the base url? <strong class="fragment">https://api.nasa.gov/planetary/apod</strong>
         </li>
       </ol>
     </section>
     <section>
       <h3>Example: NASA APOD (Astronomy Photo of the Day) API</h3>
       <p>Examples:</p>
       <ul>
         <li>Photo of the day data (for current day):
<a href="https://api.nasa.gov/nasa/planetary/apod?api_key=DEMO_KEY">https://api.nasa.gov/nasa/planetary/apod?api_key=DEMO_KEY</a>
         </li>
         <li>Photo of the day data (for a given date):
<a
href="https://api.nasa.gov/nasa/planetary/apod?api_key=DEMO_KEY&date=2018-09-30">https://api.nasa.gov/nasa/planetary/apod?api_key=DEMO_KEY&date=2018-09-30</a>
         </li>
       </ul>
   </section>
   <section>
     <h2>Example Using the NASA API!</h2>
   </section>
 -->

  <script src="../../site/reveal/lib/js/head.min.js"></script>
  <script src="../../site/reveal/js/reveal.js"></script>

  <script>
    Reveal.initialize({
      controls: true,
      progress: true,
      history: true,
      center: true,

      transition: 'slide', // none/fade/slide/convex/concave/zoom

      // More info https://github.com/hakimel/reveal.js#dependencies
      dependencies: [{
          src: '../../site/reveal/lib/js/classList.js',
          condition: function() {
            return !document.body.classList;
          }
        },
        {
          src: '../../site/reveal/plugin/markdown/marked.js',
          condition: function() {
            return !!document.querySelector('[data-markdown]');
          }
        },
        {
          src: '../../site/reveal/plugin/markdown/markdown.js',
          condition: function() {
            return !!document.querySelector('[data-markdown]');
          }
        },
        {
          src: '../../site/reveal/plugin/highlight/highlight.pack.js',
          async: true,
          callback: function() {
            hljs.initHighlightingOnLoad();
          }
        },
        { src: '../../site/reveal/plugin/zoom-js/zoom.js', async: true },
        { src: '../../site/reveal/plugin/notes/notes.js', async: true },
        { src: '../../site/reveal/plugin/search/search.js', async: true },
        { src: '../../site/reveal/plugin/print-pdf/printpdfbtn.js', async: true }
      ]
    });
  </script>
</body>
</html>
